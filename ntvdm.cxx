// NT Virtual DOS Machine. Not the real one, but one that works on 64-bit Windows
// Written by David Lee
// This only simulates a small subset of DOS and BIOS behavior. It's enough to run some
// apps including Turbo Pascal 1.00A and 3.02A. But not much else.
// No graphics, sound, mouse, or anything else not needed for simple command-line apps.
// It kinda sorta runs gwbasic -- the screen is a bit of a mess but apps load and run.
// Works with masm.exe V1.10 and link.exe V2.00 from MS-DOS v2.0
// Also works with the reason I made this -- to test apps generated by the BA basic compiler.
//
// Useful: http://www2.ift.ulaval.ca/~marchand/ift17583/dosints.pdf
//         https://en.wikipedia.org/wiki/Program_Segment_Prefix
//         https://stanislavs.org/helppc/bios_data_area.html

#define UNICODE

#include <time.h>
#include <sys/timeb.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <conio.h>
#include <direct.h>
#include <io.h>
#include <assert.h>
#include <vector>

#include <djltrace.hxx>
#include <djl_con.hxx>
#include <djl_perf.hxx>
#include <djl_cycle.hxx>
#include <djl8086d.hxx>
#include "i8086.hxx"

struct FileEntry
{
    char path[ MAX_PATH ];
    FILE * fp;
    WORD handle;
};

struct ExeHeader
{
    unsigned short signature;
    unsigned short bytes_in_last_block;
    unsigned short blocks_in_file;
    unsigned short num_relocs;
    unsigned short header_paragraphs;
    unsigned short min_extra_paragraphs;
    unsigned short max_extra_paragraphs;
    unsigned short ss;
    unsigned short sp;
    unsigned short checksum;
    unsigned short ip;
    unsigned short cs;
    unsigned short reloc_table_offset;
    unsigned short overlay_number;
};

struct ExeRelocation
{
    unsigned short offset;
    unsigned short segment;
};

const DWORD ScreenBufferSize = 2 * 80 * 25;
const DWORD ScreenBufferAddress = 0xb8000;
static WORD blankLine[80] = {0};
static HANDLE g_hFindFirst = INVALID_HANDLE_VALUE;
static const DWORD hookedVectorIRet = 0x00600004;           // this is in segment::offset format
static bool g_TimerInterrupt1CHooked = false;

CDJLTrace tracer;
bool g_haltExecution = false;
byte * g_DiskTransferAddress;
const DWORD AppSegmentOffset = 0x20000;           // base address in the vm. 128k. DOS uses 0x1920
const WORD AppSegment = AppSegmentOffset / 16;    // works at segment 0 as well, but for fun...
static vector<FileEntry> g_fileEntries;
static WORD g_nextFileHandle = 10; // 0-4 are reserved in DOS stdin, stdout, stderr, stdaux, stdprn
static bool g_use80x25 = false;
static byte g_videoMode = 2; // 2=80x25 16 grey, 3=80x25 16 colors, 7=80x25 b/w,
static byte g_screenBuffer[ ScreenBufferSize ]; // used to check for changes
static HANDLE g_hConsole = 0;
static unsigned char g_curRow = 0, g_curCol = 0;
static bool g_forceConsole = false;
ConsoleConfiguration g_consoleConfig;

#pragma pack( push, 1 )
struct DosFindFile
{
    uint8_t undocumented[ 0x15 ];

    uint8_t file_attributes;
    uint16_t file_time;
    uint16_t file_date;
    uint32_t file_size;
    char file_name[ 13 ];          // 8.3 blanks stripped null-terminated
};
#pragma pack(pop)

FILE * RemoveFileEntry( WORD handle )
{
    for ( size_t i = 0; i < g_fileEntries.size(); i++ )
    {
        if ( handle == g_fileEntries[ i ].handle )
        {
            FILE * fp = g_fileEntries[ i ].fp;
            tracer.Trace( "removing file entry %s: %p\n", g_fileEntries[ i ].path, fp );
            g_fileEntries.erase( g_fileEntries.begin() + i );
            return fp;
        }
    }

    tracer.Trace( "ERROR: could not remove file entry for handle %u\n", handle );
    return 0;
} //RemoveFileEntry

FILE * FindFileEntry( WORD handle )
{
    for ( size_t i = 0; i < g_fileEntries.size(); i++ )
    {
        if ( handle == g_fileEntries[ i ].handle )
        {
            tracer.Trace( "found file entry '%s': %p\n", g_fileEntries[ i ].path, g_fileEntries[ i ].fp );
            return g_fileEntries[ i ].fp;
        }
    }

    tracer.Trace( "ERROR: could not find file entry for handle %u\n", handle );
    return 0;
} //FindFileEntry

BOOL isPressed( int vkey )
{
    SHORT s = GetAsyncKeyState( vkey );
    return 0 != ( 0x8000 & s );
} //isPressed

BOOL keyState( int vkey )
{
    SHORT s = GetAsyncKeyState( vkey );
    return 0 != ( 0x1000 & s );
} //keyState

char printable( byte x )
{
    if ( x < ' ' || x >= 127 )
        return ' ';
    return x;
} //printable

void DumpBinaryData( byte * pData, DWORD length, DWORD indent )
{
    __int64 offset = 0;
    __int64 beyond = length;
    const __int64 bytesPerRow = 32;
    byte buf[ bytesPerRow ];

    while ( offset < beyond )
    {
        tracer.Trace( "" );

        for ( DWORD i = 0; i < indent; i++ )
            tracer.TraceQuiet( " " );

        tracer.TraceQuiet( "%#10llx  ", offset );

        __int64 cap = __min( offset + bytesPerRow, beyond );
        __int64 toread = ( ( offset + bytesPerRow ) > beyond ) ? ( length % bytesPerRow ) : bytesPerRow;

        memcpy( buf, pData + offset, toread );

        for ( __int64 o = offset; o < cap; o++ )
            tracer.TraceQuiet( "%02x ", buf[ o - offset ] );

        DWORD spaceNeeded = ( bytesPerRow - ( cap - offset ) ) * 3;

        for ( ULONG sp = 0; sp < ( 1 + spaceNeeded ); sp++ )
            tracer.TraceQuiet( " " );

        for ( __int64 o = offset; o < cap; o++ )
        {
            char ch = buf[ o - offset ];

            if ( ch < ' ' || 127 == ch )
                ch = '.';
            tracer.TraceQuiet( "%c", ch );
        }

        offset += bytesPerRow;

        tracer.TraceQuiet( "\n" );
    }
} //DumpBinaryData

/*
            // return keyboard flags in AL
            // (not tested yet)

            byte b = 0;
            b |= isPressed( VK_RSHIFT );
            b |= ( isPressed( VK_LSHIFT ) << 1 );
            b |= ( ( isPressed( VK_LCONTROL ) || isPressed( VK_RCONTROL ) ) << 2 );
            b |= ( ( isPressed( VK_LMENU ) || isPressed( VK_RMENU ) ) << 3 ); // alt
            b |= ( keyState( VK_SCROLL ) << 4 );
            b |= ( keyState( VK_NUMLOCK ) << 5 );
            b |= ( keyState( VK_CAPITAL ) << 6 );
            b |= ( keyState( VK_INSERT ) << 7 );


            regs8[REG_AL] = _getch();
*/


#define DOS_FILENAME_SIZE 13 // 8 + 3 + '.' + 0-termination
#pragma pack( push, 1 )
struct DOSFCB
{
    byte drive;
    char name[8];
    char ext[3];
    WORD curBlock;
    WORD recSize;
    DWORD fileSize;
    WORD date;
    WORD time;
    byte reserved[8];
    byte curRecord;
    DWORD recNumber;      // where random reads start

    void SetFP( FILE * fp ) { * ( (FILE **) & ( this->reserved ) ) = fp; }
    FILE * GetFP() { return * ( (FILE **) &this->reserved ); }

    void Trace()
    {
        assert( 0x0 == offsetof( DOSFCB, drive ) );
        assert( 0x1 == offsetof( DOSFCB, name ) );
        assert( 0x9 == offsetof( DOSFCB, ext ) );
        assert( 0xc == offsetof( DOSFCB, curBlock ) );
        assert( 0xe == offsetof( DOSFCB, recSize ) );
        assert( 0x10 == offsetof( DOSFCB, fileSize ) );
        assert( 0x14 == offsetof( DOSFCB, date ) );
        assert( 0x16 == offsetof( DOSFCB, time ) );
        assert( 0x18 == offsetof( DOSFCB, reserved ) );
        assert( 0x20 == offsetof( DOSFCB, curRecord ) );
        assert( 0x21 == offsetof( DOSFCB, recNumber ) );

        tracer.Trace( "  fcb: %p\n", this );
        tracer.Trace( "    drive        %u\n", this->drive );
        tracer.Trace( "    filename     '%c%c%c%c%c%c%c%c'\n",
                      this->name[0],this->name[1],this->name[2],this->name[3],
                      this->name[4],this->name[5],this->name[6],this->name[7] );
        tracer.Trace( "    ext          '%c%c%c'\n", this->ext[0],this->ext[1],this->ext[2] );
        tracer.Trace( "    curBlock:    %u\n", this->curBlock );
        tracer.Trace( "    recSize:     %u\n", this->recSize );
        tracer.Trace( "    fileSize:    %u\n", this->fileSize );
        tracer.Trace( "    reserved/fp: %p\n", GetFP() );
        tracer.Trace( "    curRecord:   %u\n", this->curRecord );
        tracer.Trace( "    recNumber:   %u\n", this->recNumber );
    }
};
#pragma pack(pop)

bool GetDOSFilename( DOSFCB &fcb, char * filename )
{
    char * orig = filename;

    for ( int i = 0; i < 8; i++ )
    {
        if ( ' ' == fcb.name[i] || 0 == fcb.name[i] )
            break;

        *filename++ = fcb.name[i];
    }

    *filename++ = '.';

    for ( int i = 0; i < 3; i++ )
    {
        if ( ' ' == fcb.ext[i] || 0 == fcb.ext[i] )
            break;

        *filename++ = fcb.ext[i];
    }

    *filename = 0;

    return ( 0 != *orig && '.' != *orig );
} //GetDOSFilename

byte * GetMem( WORD seg, WORD offset )
{
    return memory + ( ( ( (DWORD) seg ) << 4 ) + offset );
} //GetMem

byte * GetVideoMem()
{
    return memory + ScreenBufferAddress;
} //GetVideoMem

void SetCursorPos()
{
    assert( g_use80x25 );
    COORD pos;
    pos.X = g_curCol;
    pos.Y = g_curRow;
    SetConsoleCursorPosition( g_hConsole, pos );
} //SetCursorPos

void UpdateDisplay()
{
    assert( g_use80x25 );
    byte * pbuf = GetVideoMem();

    // DOS character attributes are the same as Windows; just copy them

    if ( memcmp( g_screenBuffer, pbuf, ScreenBufferSize ) )
    {
        CONSOLE_SCREEN_BUFFER_INFOEX csbi = { 0 };
        csbi.cbSize = sizeof csbi;
        GetConsoleScreenBufferInfoEx( g_hConsole, &csbi );

        tracer.Trace( "UpdateDisplay: csbi size %d %d, window %d %d %d %d\n", csbi.dwSize.X, csbi.dwSize.Y,
                      csbi.srWindow.Left, csbi.srWindow.Top, csbi.srWindow.Right, csbi.srWindow.Bottom );

        memcpy( g_screenBuffer, pbuf, ScreenBufferSize );

        for ( WORD y = 0; y < 25; y++ )
        {
            char ac[80];
            for ( WORD x = 0; x < 80; x++ )
                ac[ x ] = pbuf[ y * 80 * 2 + x * 2 ];

            COORD pos;
            pos.X = 0;
            pos.Y = y;
            SetConsoleCursorPosition( g_hConsole, pos );
            BOOL ok = WriteConsoleA( g_hConsole, ac, 80, 0, 0 );
            if ( !ok )
                tracer.Trace( "writeconsolea failed with error %d\n", GetLastError() );

            WORD at[80];
            for ( WORD x = 0; x < 80; x++ )
            {
                byte attr = pbuf[ 1 + y * 80 * 2 + x * 2 ];
                WORD winA = (WORD) attr;

                bool bgIntense = 0 != ( attr & 0x80 );
                bool fgIntense = 0 != ( attr & 0x08 );
                bool bgWhite = 0 != ( attr & 0x70 );
                bool fgWhite = 0 != ( attr & 0x07 );

                if ( 0 == attr )
                    winA = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY;
                at[ x ] = winA;
            }

            DWORD dwWritten;
            ok = WriteConsoleOutputAttribute( g_hConsole, at, 80, pos, &dwWritten );
            if ( !ok )
                tracer.Trace( "writeconsoleoutputattribute failed with error %d\n", GetLastError() );
        }

        SetCursorPos();
    }
} //UpdateDisplay

void ClearDisplay()
{
    assert( g_use80x25 );
    byte * pbuf = GetVideoMem();

    for ( WORD y = 0; y < 25; y++ )
        memcpy( pbuf + ( y * 2 * 80 ), blankLine, sizeof( blankLine ) );
} //ClearDisplay

void ApplyFormatting( byte attribute )
{
    // 7                    6 5 4         3                    2 1 0
    // background intensity background    foreground intensity foreground
    //
    // 0x70 means background white not intense, foreground black
    // 0x0f means backround black not intense, foreground intense and white

    byte attr = cpu.bl();
    bool bgIntense = 0 != ( attr & 0x80 );
    bool fgIntense = 0 != ( attr & 0x08 );
    bool bgWhite = 0 != ( attr & 0x70 );
    bool fgWhite = 0 != ( attr & 0x07 );

    if ( fgIntense )
        printf( "%c[1m", 27 );
    else
        printf( "%c[22m", 27 );
} //ApplyFormatting

BOOL WINAPI ControlHandler( DWORD fdwCtrlType )
{
    if ( CTRL_C_EVENT == fdwCtrlType )
    {
        g_haltExecution = true;
        cpu.end_emulation();
        return TRUE;
    }

    return FALSE;
} //ControlHandler

#define IntCmd( i, c ) ( ( ( (uint16_t) i ) << 8 ) | c )

struct IntInfo
{
    byte i;  // interrupt #
    byte c;  // ah
    const char * name;
};

const IntInfo intsNoAH[] =
{
   { 0x00, 0, "divide error" },
   { 0x01, 0, "single-step" },
   { 0x02, 0, "non-maskable interrupt" },
   { 0x03, 0, "1-byte interrupt" },
   { 0x04, 0, "internal overflow" },
   { 0x05, 0, "print-screen key" },
   { 0x06, 0, "undefined opcode" },
   { 0x08, 0, "hardware timer interrupt" },
   { 0x11, 0, "bios equipment determination" },
   { 0x1c, 0, "software tick tock" },
   { 0x20, 0, "cp/m compatible exit app" },
   { 0x21, 0, "generic dos interrupt" },
   { 0x22, 0, "end application" },
   { 0x23, 0, "control c exit address" },
   { 0x24, 0, "fatal error handler address" },
   { 0x2a, 0, "network information" },
   { 0x2f, 0, "dos multiplex" },
};

const IntInfo ints[] =
{
    { 0x10, 0x00, "set video mode" },
    { 0x10, 0x01, "set cursor size" },
    { 0x10, 0x02, "set cursor position" },
    { 0x10, 0x03, "get cursor position" },
    { 0x10, 0x05, "set active displaypage" },
    { 0x10, 0x06, "scroll window up" },
    { 0x10, 0x07, "scroll window down" },
    { 0x10, 0x08, "read attributes+character at cursor position" },
    { 0x10, 0x09, "output character" },
    { 0x10, 0x0a, "output character only" },
    { 0x10, 0x0f, "get video mode" },
    { 0x10, 0x10, "set palette registers" },
    { 0x10, 0x11, "character generator ega" },
    { 0x10, 0x12, "alternate select ega" },
    { 0x10, 0x13, "write character string" },
    { 0x10, 0x14, "lcd handler" },
    { 0x10, 0x15, "return physical display characteristics" },
    { 0x10, 0x1b, "undocumented. qbasic apps call this" },
    { 0x10, 0xef, "undocumented. qbasic apps call this" },
    { 0x12, 0x00, "get memory size" },
    { 0x16, 0x00, "get character" },
    { 0x16, 0x01, "keyboard status" },
    { 0x1a, 0x00, "read real time clock" },
    { 0x21, 0x00, "exit app" },
    { 0x21, 0x02, "output character" },
    { 0x21, 0x09, "print string $-terminated" },
    { 0x21, 0x0a, "buffered keyboard input" },
    { 0x21, 0x0c, "clear input buffer and execute int 0x21 on AL" },
    { 0x21, 0x0f, "open using FCB" },
    { 0x21, 0x10, "close using FCB" },
    { 0x21, 0x13, "delete file using FCBs" },
    { 0x21, 0x16, "create file using FCBs" },
    { 0x21, 0x17, "rename file using FCBs" },
    { 0x21, 0x19, "get default drive" },
    { 0x21, 0x1a, "set disk transfer address" },
    { 0x21, 0x22, "random write using FCBs" },
    { 0x21, 0x23, "get file size using FCBs" },
    { 0x21, 0x25, "set interrupt vector" },
    { 0x21, 0x27, "random block read using FCB" },
    { 0x21, 0x28, "write random using FCBs" },
    { 0x21, 0x29, "parse filename" },
    { 0x21, 0x2a, "get system date" },
    { 0x21, 0x2c, "get system time" },
    { 0x21, 0x30, "get version number" },
    { 0x21, 0x33, "get/set ctrl-break status" },
    { 0x21, 0x35, "get interrupt vector" },
    { 0x21, 0x36, "get disk space" },
    { 0x21, 0x37, "get query switchchar" },
    { 0x21, 0x38, "get/set country dependent information" },
    { 0x21, 0x3c, "create file" },
    { 0x21, 0x3d, "open file" },
    { 0x21, 0x3e, "close file" },
    { 0x21, 0x3f, "read from file using handle" },
    { 0x21, 0x40, "write to file using handle" },
    { 0x21, 0x41, "delete file" },
    { 0x21, 0x42, "move file pointer (seek)" },
    { 0x21, 0x43, "get/put file attributes" },
    { 0x21, 0x44, "ioctl" },
    { 0x21, 0x47, "get current directory" },
    { 0x21, 0x4a, "modify memory allocation" },
    { 0x21, 0x4c, "exit app" },
    { 0x21, 0x4e, "find first asciz" },
    { 0x21, 0x4f, "find next asciz" },
    { 0x21, 0x56, "rename file" },
};

const char * getint( byte i, byte c )
{
    for ( int x = 0; x < _countof( ints ); x++ )
        if ( ints[ x ].i == i && ints[ x ].c == c )
            return ints[ x ].name;

    for ( int x = 0; x < _countof( intsNoAH ); x++ )
        if ( intsNoAH[ x ].i == i )
            return intsNoAH[ x ].name;

    return "unknown";
} //getint

uint8_t i8086_invoke_in( uint16_t port )
{
    if ( 0x3da )
    {
        // toggle this or apps will spin waiting for the I/O port to work.

        static uint8_t cga_status = 9;
        cga_status ^= 9;
        return cga_status;
    }

    return 0;
} //i8086_invoke_in

void i8086_invoke_halt()
{
    g_haltExecution = true;
} // i8086_invoke_halt

void ProcessFoundFile( DosFindFile * pff, WIN32_FIND_DATAA & fd )
{
    tracer.Trace( "actual found filename: '%s'\n", fd.cFileName );
    if ( 0 != fd.cAlternateFileName[ 0 ] )
        strcpy( pff->file_name, fd.cAlternateFileName );
    else
    {
        assert( strlen( fd.cFileName ) < _countof( pff->file_name ) );
        strcpy( pff->file_name, fd.cFileName );
    }
    pff->file_size = ( fd.nFileSizeLow );

    // these bits are the same
    pff->file_attributes = ( fd.dwFileAttributes & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY |
                                                     FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE ) );

    FILETIME ft = fd.ftLastWriteTime;
    SYSTEMTIME st = {0};
    FileTimeToSystemTime( &ft, &st );

    // low 5 bits seconds, next 6 bits minutes, high 5 bits hours

    pff->file_time = st.wSecond;
    pff->file_time |= ( st.wMinute << 5 );
    pff->file_time |= ( st.wHour << 11 );

    // low 5 bits day, next 4 bits month, high 7 bits year less 1980

    pff->file_date = st.wDay;
    pff->file_date |= ( st.wMonth << 5 );
    pff->file_date |= ( ( st.wYear - 1980 ) << 9 );

    tracer.Trace( "  search found '%s', size %u\n", pff->file_name, pff->file_size );
} //ProcessFoundFile


void PerhapsFlipTo80x25()
{
    static bool firstTime = true;

    if ( firstTime )
    {
        firstTime = false;
        if ( !g_forceConsole )
        {
            g_use80x25 = true;
            g_consoleConfig.EstablishConsole( 80, 25, ControlHandler  );
        }
    }
} //PerhapsFlipTo80x25

void i8086_invoke_interrupt( uint8_t interrupt_num )
{
    static char cwd[ MAX_PATH ];
    static char curPath[ MAX_PATH ];
    static bool int16ungetAvailable = false;
    static int int16ungetChar = 0;
    static int int16ungetScancode = 0;

    unsigned char c = cpu.ah();
    tracer.Trace( "int %02x ah %02x al %02x bx %04x cx %04x dx %04x ds %04x cs %04x ss %04x es %04x %s\n",
                  interrupt_num, cpu.ah(), cpu.al(),
                  cpu.bx, cpu.cx, cpu.dx,
                  cpu.ds, cpu.cs, cpu.ss, cpu.es,
                  getint( interrupt_num, c ) );

    switch( IntCmd( interrupt_num, c ) )
    {
        case IntCmd( 0x21, 0 ):
        {
            // terminate program

            g_haltExecution = true;
            cpu.end_emulation();
            return;
        }
        case IntCmd( 0x21, 2 ):
        {
            // output character 

            char ch = cpu.dl();
            if ( 0x0d != ch )
                printf( "%c", ch );

            return;
        }
        case IntCmd( 0x21, 6 ):
        {
            // direct console character I/O
            // DL = 0xff means get input into AL if available and set ZF to 0. Set ZF to 1 if no character is available
            // DL = !0xff means output the character

            if ( 0xff == cpu.dl() )
            {
                // input

                if ( _kbhit() )
                {
                    cpu.fZero = false;
                    cpu.set_al( _getch() );
                }
                else
                    cpu.fZero = true;
            }
            else
            {
                // output

                char ch = cpu.dl();
                if ( 0x0d != ch )
                    printf( "%c", ch );
            }

            return;
        }
        case IntCmd( 0x21, 9 ):
        {
            // print string. prints chars up to a dollar sign $

            char * p = (char *) GetMem( cpu.ds, cpu.dx );
            DumpBinaryData( (byte *) p, 0x40, 2 );
            while ( *p && '$' != *p )
                printf( "%c", *p++ );

            return;
        }
        case IntCmd( 0x21, 0xa ):
        {
            // Buffered Keyboard input. DS::DX pointer to buffer. byte 0 count in, byte 1 count out excluding CR, byte 2 starts the response

            byte * p = GetMem( cpu.ds, cpu.dx );
            uint8_t maxLen = p[0];

            char * result = gets_s( (char *) p + 2, maxLen );
            if ( result )
                p[1] = strlen( result );
            else
                p[1] = 0;

            return;
        }
        case IntCmd( 0x21, 0xc ):
        {
            // clear input buffer and execute int 0x21 on command in register AL

            while ( _kbhit() )
                _getch();

            cpu.set_ah( cpu.al() );
            tracer.Trace( "recursing to int 0x21 with command %#x\n", cpu.ah() );
            i8086_invoke_interrupt( 0x21 );

            return;
        } 
        case IntCmd( 0x21, 0xf ):
        {
            // open using FCB

            tracer.Trace( "open using FCB. ds %u dx %u\n", cpu.ds, cpu.dx );

            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "  mem: %p, pfcb %p\n", memory, pfcb );
            DumpBinaryData( (byte *) pfcb, sizeof DOSFCB, 2 );

            cpu.set_al( 0xff );
            char filename[ DOS_FILENAME_SIZE ];
            if ( GetDOSFilename( *pfcb, filename ) )
            {
                tracer.Trace( "  opening %s\n", filename );
                pfcb->SetFP( 0 );
    
                FILE * fp = fopen( filename, "r+b" );
                if ( fp )
                {
                    tracer.Trace( "  file opened successfully\n" );
                    pfcb->SetFP( fp );
    
                    fseek( fp, 0, SEEK_END );
                    pfcb->fileSize = ftell( fp );
                    fseek( fp, 0, SEEK_SET );
    
                    pfcb->curBlock = 0;
                    pfcb->recSize = 0x80;
    
                    pfcb->Trace();
                    cpu.set_al( 0 );
                }
                else
                    tracer.Trace( "ERROR: file open using FCB of %s failed, error %d = %s\n", filename, errno, strerror( errno ) );
            }
            else
                tracer.Trace( "ERROR: couldn't parse filename in FCB\n" );

            return;
        }
        case IntCmd( 0x21, 0x10 ):
        {
            // close file using FCB

            tracer.Trace( "close file using FCB\n" );
            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            pfcb->Trace();

            FILE * fp = pfcb->GetFP();
            if ( fp )
            {
                fclose( fp );
                pfcb->SetFP( 0 );
            }
            else
                tracer.Trace( "ERROR: file close using FCB of a file that's not open\n" );

            return;
        }
        case IntCmd( 0x21, 0x13 ):
        {
            // delete file using FCB

            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "  mem: %p, pfcb %p\n", memory, pfcb );
            DumpBinaryData( (byte *) pfcb, sizeof DOSFCB, 2 );

            cpu.set_al( 0xff );
            char filename[ DOS_FILENAME_SIZE ];
            if ( GetDOSFilename( *pfcb, filename ) )
            {
                tracer.Trace( "  deleting %s\n", filename );
    
                int removeok = !remove( filename );
                if ( removeok )
                {
                    cpu.set_al( 0 );
                    tracer.Trace( "delete successful\n" );
                }
                else
                    tracer.Trace( "ERROR: delete file failed, error %d = %s\n", errno, strerror( errno ) );
            }
            else
                tracer.Trace( "ERROR: couldn't parse filename in FCB\n" );

            return;
        }
        case IntCmd( 0x21, 0x16 ):
        {
            // create using FCB

            tracer.Trace( "create using FCB. ds %u dx %u\n", cpu.ds, cpu.dx );

            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "  mem: %p, pfcb %p\n", memory, pfcb );
            DumpBinaryData( (byte *) pfcb, sizeof DOSFCB, 2 );
            cpu.set_al( 0xff );

            char filename[ DOS_FILENAME_SIZE ];
            if ( GetDOSFilename( *pfcb, filename ) )
            {
                tracer.Trace( "  creating %s\n", filename );
                pfcb->SetFP( 0 );
    
                FILE * fp = fopen( filename, "w+b" );
                if ( fp )
                {
                    tracer.Trace( "  file created successfully\n" );
                    cpu.set_al( 0 );
                    pfcb->SetFP( fp );
    
                    pfcb->fileSize = 0;
                    pfcb->curBlock = 0;
                    pfcb->recSize = 0x80;
    
                    pfcb->Trace();
                }
                else
                    tracer.Trace( "ERROR: file create using FCB of %s failed, error %d = %s\n", filename, errno, strerror( errno ) );
            }
            else
                tracer.Trace( "ERROR: can't parse filename from FCB\n" );

            return;
        }
        case IntCmd( 0x21, 0x17 ):
        {
            // rename file using FCB. Returns AL 0 if success and 0xff on failure.

            cpu.set_al( 0xff );
            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "  mem: %p, pfcb %p\n", memory, pfcb );
            DumpBinaryData( (byte *) pfcb, sizeof DOSFCB, 2 );

            DOSFCB * pfcbNew = (DOSFCB * ) ( 0x10 + (byte *) pfcb );

            char oldFilename[ DOS_FILENAME_SIZE ] = {0};
            if ( GetDOSFilename( *pfcb, oldFilename ) )
            {
                char newFilename[ DOS_FILENAME_SIZE ] = {0};
                if ( GetDOSFilename( *pfcbNew, newFilename ) )
                {
                    tracer.Trace( "rename old name '%s', new name '%s'\n", oldFilename, newFilename );

                    if ( !rename( oldFilename, newFilename ) )
                    {
                        tracer.Trace( "rename successful\n" );
                        cpu.set_al( 0 );
                    }
                    else
                        tracer.Trace( "ERROR: can't rename file, error %d = %s\n", errno, strerror( errno ) );
                }
                else
                    tracer.Trace( "ERROR: can't parse new filename in FCB\n" );
            }
            else
                tracer.Trace( "ERROR: can't parse old filename in FCB\n" );

            return;
        }
        case IntCmd( 0x21, 0x19 ):
        {
            // get current default drive. 0 == a:, 1 == b:, etc. returned in AL

            GetCurrentDirectoryA( sizeof cwd, cwd );
            _strupr( cwd );
            cpu.set_al( cwd[0] - 'A' );
            return;
        }
        case IntCmd( 0x21, 0x1a ):
        {
            // set disk transfer address

            byte * old = g_DiskTransferAddress;
            g_DiskTransferAddress = (byte *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "  set disk transfer address updated from %p to %p (bx %u)\n", old, g_DiskTransferAddress, cpu.dx );

            return;
        }
        case IntCmd( 0x21, 0x22 ):
        {
            // random write using FCBs. on output, 0 if success, 1 if disk full, 2 if DTA too small
            // CX has # of records written on exit

            cpu.set_al( 1 );
            uint16_t recsToWrite = cpu.cx;
            cpu.cx = 0;
            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            pfcb->Trace();
            FILE * fp = pfcb->GetFP();
            if ( fp )
            {
                ULONG seekOffset = pfcb->recNumber * pfcb->recSize;
                tracer.Trace( "  seek offset: %u\n", seekOffset );
                int ok = !fseek( fp, seekOffset, SEEK_SET );
                if ( ok )
                {
                    size_t num_written = fwrite( g_DiskTransferAddress, recsToWrite, pfcb->recSize, fp );
                    if ( num_written )
                    {
                         tracer.Trace( "  write succeded: %u bytes\n", recsToWrite * pfcb->recSize );
                         cpu.cx = recsToWrite;
                         cpu.set_al( 0 );

                         // don't update the fcb's record number for this version of the API
                    }
                    else
                         tracer.Trace( "  write failed with error %d = %s\n", errno, strerror( errno ) );
                }
                else
                    tracer.Trace( "ERROR random block write using FCBs failed to seek, error %d = %s\n", errno, strerror( errno ) );
            }
            else
                tracer.Trace( "ERROR random block write using FCBs doesn't have an open file\n" );

            return;
        }
        case IntCmd( 0x21, 0x25 ):
        {
            // set interrupt vector

            tracer.Trace( "  setting interrupt vector %02x %s to %04x:%04x\n", cpu.al(), getint( cpu.al(), 0 ), cpu.ds, cpu.dx );
            uint16_t * pvec = (uint16_t *) GetMem( 0, 4 * (uint16_t) cpu.al() );
            pvec[0] = cpu.dx;
            pvec[1] = cpu.ds;

            if ( 0x1c == cpu.al() )
            {
                DWORD dw = ( (DWORD) cpu.ds << 16 ) | cpu.dx;
                g_TimerInterrupt1CHooked = ( hookedVectorIRet != dw );
                tracer.Trace( "timer hooked: %d\n", g_TimerInterrupt1CHooked );
            }
            return;
        }           
        case IntCmd( 0x21, 0x27 ):
        {
            // random block read using FCBs
            // CX: number of records to read
            // DS:BX pointer to the FCB.
            // on exit, AL 0 success, 1 EOF no data read, 2 dta too small, 3 eof partial read (filled with 0s)

            cpu.set_al( 1 ); // eof
            ULONG cRecords = cpu.cx;
            cpu.cx = 0;
            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "random block read using FCBs\n" );
            pfcb->Trace();
            ULONG seekOffset = pfcb->recNumber * pfcb->recSize;
            if ( seekOffset > pfcb->fileSize )
            {
                tracer.Trace( "ERROR: random read beyond end of file offset %u, filesize %u\n", seekOffset, pfcb->fileSize );
                cpu.set_al( 1 ); // eof
            }
            else if ( seekOffset == pfcb->fileSize )
            {
                tracer.Trace( "WARNING: random read at end of file offset %u, filesize %u\n", seekOffset, pfcb->fileSize );
                cpu.set_al( 1 ); // eof
            }
            else
            {
                FILE * fp = pfcb->GetFP();
                if ( fp )
                {
                    tracer.Trace( "  seek offset: %u\n", seekOffset );
                    int ok = !fseek( fp, seekOffset, SEEK_SET );
                    if ( ok )
                    {
                        ULONG askedBytes = pfcb->recSize * cRecords;
                        memset( g_DiskTransferAddress, 0, askedBytes );
                        ULONG toRead = __min( pfcb->fileSize - seekOffset, askedBytes );
                        size_t numRead = fread( g_DiskTransferAddress, toRead, 1, fp );
                        if ( numRead )
                        {
                            if ( toRead == askedBytes )
                                cpu.set_al( 0 );
                            else
                                cpu.set_al( 3 ); // eof encountered, last record is partial

                            cpu.cx = toRead / pfcb->recSize;
                            tracer.Trace( "  successfully read %u bytes, CX set to %u:\n", toRead, cpu.cx );
                            DumpBinaryData( g_DiskTransferAddress, toRead, 0 );
                            pfcb->curRecord += cRecords;;
                            pfcb->recNumber += cRecords;
                        }
                        else
                            tracer.Trace( "ERROR random block read using FCBs failed to read, error %d = %s\n", errno, strerror( errno ) );
                    }
                    else
                        tracer.Trace( "ERROR random block read using FCBs failed to seek, error %d= %s\n", errno, strerror( errno ) );
                }
                else
                    tracer.Trace( "ERROR random block read using FCBs doesn't have an open file\n" );
            }

            return;
        }
        case IntCmd( 0x21, 0x28 ):
        {
            // random block write using FCBs.
            // in: CX = number of records, DS:BX the fcb
            // out: al = 0 if success, 1 if disk full, 2 if data too smaoo, cx = number of records written

            cpu.set_al( 1 );
            uint16_t recsToWrite = cpu.cx;
            cpu.cx = 0;
            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.ds, cpu.dx );
            pfcb->Trace();
            FILE * fp = pfcb->GetFP();
            if ( fp )
            {
                ULONG seekOffset = pfcb->recNumber * pfcb->recSize;
                tracer.Trace( "  seek offset: %u\n", seekOffset );
                int ok = !fseek( fp, seekOffset, SEEK_SET );
                if ( ok )
                {
                    size_t num_written = fwrite( g_DiskTransferAddress, recsToWrite, pfcb->recSize, fp );
                    if ( num_written )
                    {
                         tracer.Trace( "  write succeded: %u bytes\n", recsToWrite * pfcb->recSize );
                         cpu.cx = recsToWrite;
                         cpu.set_al( 0 );

                         pfcb->recNumber += recsToWrite;
                    }
                    else
                         tracer.Trace( "  write failed with error %d = %s\n", errno, strerror( errno ) );
                }
                else
                    tracer.Trace( "ERROR random block write using FCBs failed to seek, error %d = %s\n", errno, strerror( errno ) );
            }
            else
                tracer.Trace( "ERROR random block write using FCBs doesn't have an open file\n" );

            return;
        }
        case IntCmd( 0x21, 0x29 ):
        {
            // parse filename
            // in: ds:si -- string to parse
            //     es:di -- buffer pointing to an fcb
            //     al:   -- bit 0: 0 parsing stops if file separator found
            //                     1 leading separator ignored
            //              bit 1: 0 drive number in fcb set to default if no drive in string
            //                     1 drive number in fcb not modified
            //              bit 2: 0 set filename in fcb to blanks if no filename in string
            //                     1 don't modify filename in fcb if no filename in string
            //              bit 3: 0 extension in fcb set to blanks if no extension in string
            //                     1 extension left unchanged if no extension in string
            // out: al:     0: no wildcards in name or extension
            //              1: wildcards appeared
            //           0xff: drive specifier invalid
            //      ds:si:  first byte after parsed string
            //      es:di:  buffer filled with unopened fcb

            char * pfile = (char *) GetMem( cpu.ds, cpu.si );
            tracer.Trace( "parse filename '%s'\n", pfile );
            DumpBinaryData( (byte *) pfile, 64, 0 );

            DOSFCB * pfcb = (DOSFCB *) GetMem( cpu.es, cpu.di );
            char * pf = pfile;

            if ( 0 == pfile[0] )
            {
                if ( 0 == ( cpu.al() & 4 ) )
                    memset( pfcb->name, ' ', _countof( pfcb->name ) );
                if ( 0 == ( cpu.al() & 8 ) )
                    memset( pfcb->ext, ' ', _countof( pfcb->ext ) );
            }
            else
            {
                memset( pfcb->name, ' ', _countof( pfcb->name ) );
                memset( pfcb->ext, ' ', _countof( pfcb->ext ) );
                for ( int i = 0; i < _countof( pfcb->name ) && *pf && *pf != '.'; i++ )
                    pfcb->name[ i ] = *pf++;
                if ( '.' == *pf )
                    pf++;
                for ( int i = 0; i < _countof( pfcb->ext ) && *pf; i++ )
                    pfcb->ext[ i ] = *pf++;
            }

            if ( strchr( pfile, '*' ) || strchr( pfile, '?' ) )
                cpu.set_al( 1 );
            else
                cpu.set_al( 0 );

            cpu.si += 1 + (uint16_t) ( pf - pfile );

            return;
        }
        case IntCmd( 0x21, 0x2a ):
        {
            // get system date. al is day of week 0-6 0=sunday, cx = year 1980-2099, dh = month 1-12, dl = day 1-31

            SYSTEMTIME st = {0};
            GetLocalTime( &st );
            cpu.set_al( st.wDayOfWeek );
            cpu.cx = st.wYear;
            cpu.set_dh( st.wMonth );
            cpu.set_dl( st.wDay );

            return;
        }           
        case IntCmd( 0x21, 0x2c ):
        {
            // get system time into DX (seconds : hundredths of a second), CX (hours : minutes)

            SYSTEMTIME st = {0};
            GetLocalTime( &st );
            cpu.set_ch( st.wHour );
            cpu.set_cl( st.wMinute );
            cpu.set_dh( st.wSecond );
            cpu.set_dl( st.wMilliseconds / 10 );

            return;
        }           
        case IntCmd( 0x21, 0x30 ):
        {
            // get version number

            cpu.set_al( 2 ); // maybe try 3.0 for wordstar?
            cpu.set_ah( 11 ); 
            //cpu.set_al( 3 ); // maybe try 3.0 for wordstar?
            //cpu.set_ah( 0 ); 

            tracer.Trace( "returning DOS version %d.%d\n", cpu.al(), cpu.ah() );
            return;
        }
        case IntCmd( 0x21, 0x33 ):
        {
            // get/set ctrl-break status

            cpu.set_dl( 0 ); // it's off regardless of what is set
            return;
        }
        case IntCmd( 0x21, 0x35 ):
        {
            // get interrupt vector. 

            uint16_t * pvec = (uint16_t *) GetMem( 0, 4 * (uint16_t) cpu.al() );
            cpu.bx = pvec[ 0 ];
            cpu.es = pvec[ 1 ];

            tracer.Trace( "  getting interrupt vector %02x %s which is %04x:%04x\n", cpu.al(), getint( cpu.al(), 0 ), cpu.es, cpu.bx );
            return;
        }
        case IntCmd( 0x21, 0x36 ):
        {
            // get disk space: in: dl code (0 default, 1 = A, 2 = B...
            // output: ax: sectors per cluster, bx = # of available clusters, cx = bytes per sector, dx = total clusters
            // use believable numbers for DOS for lots of disk space free.

            cpu.ax = 8;
            cpu.bx = 0x6fff;
            cpu.cx = 512;
            cpu.dx = 0x7fff;

            return;
        }
        case IntCmd( 0x21, 0x37 ):
        {
            // query switchchar. Undocumented but legal call in DOS 2.x

            cpu.set_dl( '/' );
            return;
        }
        case IntCmd( 0x21, 0x38 ):
        {
            // get/set country dependent information.

            cpu.fCarry = false;
            cpu.bx = 1; // USA
            byte * pinfo = GetMem( cpu.ds, cpu.dx );
            memset( pinfo, 0, 0x20 );
            pinfo[ 2 ] = '$';
            pinfo[ 4 ] = ',';
            pinfo[ 6 ] = '.';
            return;
        }
        case IntCmd( 0x21, 0x3c ):
        {
            // create file. DS:dx pointer to asciiz pathname. al= open mode (dos 2.x ignores). AX=handle

            char * path = (char *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "create file '%s'\n", path );
            cpu.ax = 3;

            FILE * fp = fopen( path, "w+b" );
            if ( fp )
            {
                FileEntry fe;
                strcpy( fe.path, path );
                fe.fp = fp;
                fe.handle = g_nextFileHandle++;
                g_fileEntries.push_back( fe );
                cpu.ax = fe.handle;
                cpu.fCarry = false;
            }
            else
            {
                tracer.Trace( "ERROR: create file sz failed with error %d = %s\n", errno, strerror( errno ) );
                cpu.ax = 2;
                cpu.fCarry = true;
            }

            return;
        }
        case IntCmd( 0x21, 0x3d ):
        {
            // open file. DS:dx pointer to asciiz pathname. al= open mode (dos 2.x ignores). AX=handle

            char * path = (char *) GetMem( cpu.ds, cpu.dx );
            DumpBinaryData( (byte *) path, 0x100, 0 );
            tracer.Trace( "open file '%s'\n", path );
            cpu.ax = 2;

            FILE * fp = fopen( path, "r+b" );
            if ( fp )
            {
                FileEntry fe;
                strcpy( fe.path, path );
                fe.fp = fp;
                fe.handle = g_nextFileHandle++;
                g_fileEntries.push_back( fe );
                cpu.ax = fe.handle;
                cpu.fCarry = false;;
            }
            else
            {
                tracer.Trace( "ERROR: open file sz failed with error %d = %s\n", errno, strerror( errno ) );
                cpu.ax = 2;
                cpu.fCarry = true;
            }

            return;
        }
        case IntCmd( 0x21, 0x3e ):
        {
            // close file handle in BX

            FILE * fp = RemoveFileEntry( cpu.bx );
            if ( fp )
            {
                tracer.Trace( "close file handle %u\n", cpu.bx );
                fclose( fp );
                cpu.fCarry = false;;
            }
            else
            {
                tracer.Trace( "ERROR: close file handle couldn't find handle %u\n", cpu.bx );
                cpu.ax = 6;
                cpu.fCarry = true;
            }

            return;
        }
        case IntCmd( 0x21, 0x3f ):
        {
            // read from file using handle. BX=handle, CX=num bytes, DS:DX: buffer
            // on output: AX = # of bytes read or if CF is set 5=access denied, 6=invalid handle.

            WORD h = cpu.bx;
            if ( h <= 4 )
            {
                // reserved handles. 0-4 are reserved in DOS stdin, stdout, stderr, stdaux, stdprn

                if ( 0 == h )
                {
                    // Callers like GWBasic ask for one character at a time but have no idea what a backspace is.
                    // So buffer until a cr, append a lf, and send that one character at a time.

                    static char acBuffer[ 128 ] = {0};

                    if ( g_use80x25 )
                        UpdateDisplay();

                    byte * p = GetMem( cpu.ds, cpu.dx );
                    cpu.fCarry = false;
                    cpu.ax = 1;

                    while ( 0 == acBuffer[ 0 ] )
                    {
                        size_t len = _countof( acBuffer );
                        char * result = gets_s( acBuffer, _countof( acBuffer ) );
                        if ( result )
                        {
                            strcat( acBuffer, "\r\n" );
                            break;
                        }
                    }
    
                    *p = acBuffer[0];
                    strcpy( acBuffer, acBuffer + 1 );
                    return;
                }
                else
                {
                    cpu.fCarry = true;
                    tracer.Trace( "attempt to read from handle %d\n", h );
                }

                return;
            }

            FILE * fp = FindFileEntry( cpu.bx );
            if ( fp )
            {
                WORD len = cpu.cx;
                byte * p = GetMem( cpu.ds, cpu.dx );
                tracer.Trace( "read from file using handle %u bytes at address %p\n", len, p );

                DWORD cur = ftell( fp );
                fseek( fp, 0, SEEK_END );
                DWORD size = ftell( fp );
                fseek( fp, cur, SEEK_SET );
                cpu.ax = 0;

                if ( cur < size )
                {
                    memset( p, 0, len );
                    DWORD toRead = __min( len, size - cur );
                    size_t numRead = fread( p, toRead, 1, fp );
                    if ( numRead )
                    {
                        cpu.ax = toRead;
                        tracer.Trace( "  successfully read %u bytes\n", toRead );
                        DumpBinaryData( p, toRead, 0 );
                    }
                }
                else
                    tracer.Trace( "ERROR: attempt to read beyond the end of file\n" );

                cpu.fCarry = false;;
            }
            else
            {
                tracer.Trace( "ERROR: read from file handle couldn't find handle %u\n", cpu.bx );
                cpu.ax = 6;
                cpu.fCarry = true;
            }

            return;
        }
        case IntCmd( 0x21, 0x40 ):
        {
            // write to file using handle. BX=handle, CX=num bytes, DS:DX: buffer
            // on output: AX = # of bytes read or if CF is set 5=access denied, 6=invalid handle.

            WORD h = cpu.bx;
            cpu.fCarry = false;
            if ( h <= 4 )
            {
                cpu.ax = cpu.cx;

                // reserved handles. 0-4 are reserved in DOS stdin, stdout, stderr, stdaux, stdprn

                byte * p = GetMem( cpu.ds, cpu.dx );

                if ( 1 == h || 2 == h )
                {
                    if ( g_use80x25 )
                    {
                        byte * pbuf = GetVideoMem();
                        DWORD offset = g_curRow * 2 * 80 + g_curCol * 2;
        
                        for ( WORD t = 0; t < cpu.cx; t++ )
                        {
                            byte ch = p[ t ];
                            if ( 0x0d == ch )
                                g_curCol = 0;
                            else if ( 0x0a == ch )
                                g_curRow++; // bugbug scroll if at bottom
                            else
                            {
                                pbuf[ offset ] = printable( p[ t ] );
                                tracer.Trace( "  writing %02x '%c' to display at row %u column %u\n", p[ t ], printable( p[ t ] ), g_curRow, g_curCol );
                                pbuf[ 1 + offset ] = 0; // no attributes
                                g_curCol++;
                                if ( g_curCol > 80 )
                                    g_curCol = 1;
                            }

                            SetCursorPos();
                        }
                    }
                    else
                    {
                        for ( WORD x = 0; x < cpu.cx; x++ )
                        {
                            if ( 0x0d != p[ x ] )
                            {
                                printf( "%c", p[ x ] );
                                tracer.Trace( "writing %02x '%c' to display\n", p[ x ], printable( p[x] ) );
                            }
                        }
                    }
                }
                return;
            }

            FILE * fp = FindFileEntry( cpu.bx );
            if ( fp )
            {
                WORD len = cpu.cx;
                byte * p = GetMem( cpu.ds, cpu.dx );
                tracer.Trace( "write file using handle, %u bytes at address %p\n", len, p );

                cpu.ax = 0;

                size_t numWritten = fwrite( p, len, 1, fp );
                if ( numWritten || ( 0 == len ) )
                {
                    cpu.ax = len;
                    tracer.Trace( "  successfully wrote %u bytes\n", len );
                    DumpBinaryData( p, len, 0 );
                }
                else
                    tracer.Trace( "ERROR: attempt to write to file failed, error %d = %s\n", errno, strerror( errno ) );

                cpu.fCarry = false;;
            }
            else
            {
                tracer.Trace( "ERROR: write to file handle couldn't find handle %u\n", cpu.bx );
                cpu.ax = 6;
                cpu.fCarry = true;
            }

            return;
        }
        case IntCmd( 0x21, 0x41 ):
        {
            // delete file: ds:dx has asciiz name of file to delete.
            // return: cf set on error, ax = error code

            char * pfile = (char *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "deleting file '%s'\n", pfile );
            int removeok = !remove( pfile );
            if ( removeok )
                cpu.fCarry = false;
            else
            {
                tracer.Trace( "ERROR: can't delete file '%s' error %d = %s\n", pfile, errno, strerror( errno ) );
                cpu.fCarry = true;
                cpu.ax = 2;
            }

            return;
        }
        case IntCmd( 0x21, 0x42 ):
        {
            // move file pointer (lseek)
            // bx == handle, cx:dx: 32-bit offset, al=mode. 0=beginning, 1=current. 2=end

            WORD handle = cpu.bx;
            FILE * fp = FindFileEntry( handle );
            if ( fp )
            {
                DWORD offset = ( ( (DWORD) cpu.cx ) << 16 ) | cpu.dx;
                byte origin = cpu.al();
                if ( origin > 2 )
                {
                    tracer.Trace( "ERROR: move file pointer file handle has invalid mode/origin %u\n", origin );
                    cpu.ax = 1;
                    cpu.fCarry = true;
                    return;
                }

                tracer.Trace( "move file pointer using handle %u to %u bytes from %s\n", handle, offset,
                              0 == origin ? "end" : 1 == origin ? "current" : "end" );

                DWORD cur = ftell( fp );
                fseek( fp, 0, SEEK_END );
                DWORD size = ftell( fp );
                fseek( fp, cur, SEEK_SET );
                tracer.Trace( "file size is %u\n", size );

                if ( 0 == origin )
                    fseek( fp, offset, SEEK_SET );
                else if ( 1 == origin )
                    fseek( fp, offset, SEEK_CUR );
                else 
                    fseek( fp, offset, SEEK_END );

                cur = ftell( fp );
                cpu.ax = cur & 0xffff;
                cpu.dx = ( cur >> 16 ) & 0xffff;

                cpu.fCarry = false;;
            }
            else
            {
                tracer.Trace( "ERROR: move file pointer file handle couldn't find handle %u\n", handle );
                cpu.ax = 6;
                cpu.fCarry = true;
            }

            return;
        }
        case IntCmd( 0x21, 0x43 ):
        {
            // get/put file attributes
            // al: 0 == get file attributes, 1 == put file attributes
            // cx: attributes (bits: 0 ro, 1 hidden, 2 system, 3 volume, 4 subdir, 5 archive)
            // ds:dx: asciz filename
            // returns: ax = error code if CF set. CX = file attributes on get.

            char * pfile = (char *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "get/put file attributes on file '%s'\n", pfile );
            cpu.fCarry = true;

            if ( 0 == cpu.al() ) // get
            {
                DWORD attr = GetFileAttributesA( pfile );
                if ( INVALID_FILE_ATTRIBUTES != attr )
                {
                    cpu.fCarry = false;
                    cpu.cx = ( attr & ( FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY |
                                        FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE ) );
                }
            }
            else
            {
                BOOL ok = SetFileAttributesA( pfile, cpu.cx );
                cpu.fCarry = !ok;
            }

            tracer.Trace( "result of get/put file attributes: %d\n", !cpu.fCarry );

            return;
        }
        case IntCmd( 0x21, 0x44 ):
        {
            // i/o control for devices (ioctl)

            byte subfunction = cpu.al();
            // handles 0-4 are reserved in DOS stdin, stdout, stderr, stdaux, stdprn
            WORD handle = cpu.bx;
            WORD count = cpu.cx;
            byte * pbuf = GetMem( cpu.ds, cpu.dx );

            tracer.Trace( "ioctl subfunction %u, get device information for handle %u, count %u\n", subfunction, handle, count );
            switch ( subfunction )
            {
                case 0:
                {
                    // get device information

                    cpu.dx = 0;

                    if ( handle <= 4 )
                    {
                        //cpu.dx |= ( 1 == handle ) ? 1 : 2;
                        //cpu.dx |= ( 1 << 7 ); // device, not a file
                    }

                    break;
                }
                case 1:
                {
                    // set device information (ignore)

                    break;
                }
                default:
                {
                    tracer.Trace( "UNIMPLEMENTED IOCTL subfunction %#x\n", cpu.al() );
                    break;
                }
            }

            return;
        }
        case IntCmd( 0x21, 0x47 ):
        {
            // get current directory. BX = drive number, DS:SI = pointer to a 64-byte null-terminated buffer.
            // CF set on error. AX=15 for invalid drive

            cpu.fCarry = true;
            if ( GetCurrentDirectoryA( sizeof cwd, cwd ) )
            {
                char * paststart = cwd + 3;
                if ( strlen( paststart ) <= 63 )
                {
                    strcpy( (char *) GetMem( cpu.ds, cpu.si ), paststart );
                    cpu.fCarry = false;;
                }
            }
            else
                tracer.Trace( "ERROR: unable to get the current working directory, error %d\n", GetLastError() );

            return;
        }
        case IntCmd( 0x21, 0x4a ):
        {
            // modify memory allocation. fake it

            cpu.fCarry = false;;
            cpu.bx = 0xffff;

            return;
        }
        case IntCmd( 0x21, 0x4c ):
        {
            // exit app

            cpu.end_emulation();
            g_haltExecution = true;
            return;
        }
      
        case IntCmd( 0x21, 0x4e ):
        {
            // find first asciz
            // in: cx = attribute used during search: 7..0 unused, archive, subdir, volume, system, hidden, read-only
            //     ds:dx pointer to null-terminated ascii string including wildcards
            // out: CF: true on error, false on success
            //      ax: error code if CF is true.
            //      disk transfer address: DosFindFile

            cpu.fCarry = true;
            DosFindFile * pff = (DosFindFile* ) g_DiskTransferAddress;
            char * psearch_string = (char *) GetMem( cpu.ds, cpu.dx );
            tracer.Trace( "Find First Asciz for pattern '%s'\n", psearch_string );

            tracer.Trace( "offset of file_name: %02x\n", offsetof( DosFindFile, file_name ) );

            if ( INVALID_HANDLE_VALUE != g_hFindFirst )
            {
                FindClose( g_hFindFirst );
                g_hFindFirst = INVALID_HANDLE_VALUE;
            }

            WIN32_FIND_DATAA fd = {0};
            g_hFindFirst = FindFirstFileA( psearch_string, &fd );
            if ( INVALID_HANDLE_VALUE != g_hFindFirst )
            {
                ProcessFoundFile( pff, fd );
                cpu.fCarry = false;
            }
            else
            {
                cpu.ax = GetLastError(); // interesting errors actually match
                tracer.Trace( "WARNING: find first file failed, error %d\n", GetLastError() );
            }

            return;
        }
      
        case IntCmd( 0x21, 0x4f ):
        {
            // find next asciz

            cpu.fCarry = true;
            DosFindFile * pff = (DosFindFile* ) g_DiskTransferAddress;
            tracer.Trace( "Find Next Asciz\n" );
    
            if ( INVALID_HANDLE_VALUE != g_hFindFirst )
            {
                WIN32_FIND_DATAA fd = {0};
                BOOL found = FindNextFileA( g_hFindFirst, &fd );
                if ( found )
                {
                    ProcessFoundFile( pff, fd );
                    cpu.fCarry = false;
                }
                else
                {
                    cpu.ax = 12; // no more files
                    tracer.Trace( "WARNING: find next file found no more, error %d\n", GetLastError() );
                }
            }
            else
            {
                cpu.ax = 12; // no more files
                tracer.Trace( "ERROR: search for next without a prior successful search for first\n" );
            }

            return;
        }
        case IntCmd( 0x21, 0x56 ):
        {
            // rename file: ds:dx old name, es:di new name
            // CF set on error, AX with error code

            char * poldname = (char *) GetMem( cpu.ds, cpu.dx );
            char * pnewname = (char *) GetMem( cpu.es, cpu.di );

            tracer.Trace( "renaming file '%s' to '%s'\n", poldname, pnewname );
            int renameok = ! rename( poldname, pnewname );
            if ( renameok )
                cpu.fCarry = false;
            else
            {
                tracer.Trace( "ERROR: can't rename file '%s' as '%s' error %d = %s\n", poldname, pnewname, errno, strerror( errno ) );
                cpu.fCarry = true;
                cpu.ax = 2;
            }

            return;
        }
        case IntCmd( 0x1a, 0 ):
        {
            // real time. get ticks since system boot. 18.2 ticks per second.

            ULONGLONG milliseconds = GetTickCount64();
            milliseconds *= 1821;
            milliseconds /= 100000;
            cpu.set_al( 0 );

#if false
            static ULONGLONG fakems = 0;
            fakems += 10;
            milliseconds = fakems;
#endif

            cpu.set_ch( ( milliseconds >> 24 ) & 0xff );
            cpu.set_cl( ( milliseconds >> 16 ) & 0xff );
            cpu.set_dh( ( milliseconds >> 8 ) & 0xff );
            cpu.set_dl( milliseconds & 0xff );

            return;
        }
        case IntCmd( 0x10, 0 ):
        {
            // set video mode. 0 = 40x25, 3 = 80x25, 13h = graphical

            byte mode = cpu.al();
            tracer.Trace( "set video mode to %#x\n", mode );

            if ( 2 == mode || 3 == mode || 7 == mode )
                g_videoMode = mode;

            return;
        }
        case IntCmd( 0x10, 1 ):
        {
            // set cursor size. ch = start line, cl = end line

            return;
        }
        case IntCmd( 0x10, 2 ):
        {
            tracer.Trace( "  set cursor position to %d %d\n", cpu.dh(), cpu.dl() );

            WORD lastRow = g_curRow;
            WORD lastCol = g_curCol;

            g_curRow = cpu.dh();
            g_curCol = cpu.dl();

            if ( g_use80x25 )
                SetCursorPos();
            else if ( 0 == g_curCol && ( g_curRow == ( lastRow + 1 ) ) )
                printf( "\n" );

            return;
        }
        case IntCmd( 0x10, 3 ):
        {
            // get cursor position

            cpu.set_dh( g_curRow );
            cpu.set_dl( g_curCol );
            cpu.set_ch( 0 );
            cpu.set_cl( 0 );

            tracer.Trace( "  get cursor position %d %d\n", cpu.dh(), cpu.dl() );

            return;
        }
        case IntCmd( 0x10, 5 ):
        {
            // set active display page (ignore)

            return;
        }
        case IntCmd( 0x10, 6 ):
        {
            // scroll window up: AL: # of lines to scroll. If 0, clear entire window
            // bh: display attribute for blank lines
            // ch: row number of upper left corner
            // cl: column number of upper left corner
            // dh: row number of lower left corner
            // dl: column number of lower right corner
            // lines are inserted at the bottom with all lines moving up.

            if ( g_use80x25 )
            {
                //printf( "%c[%dS", 27, cpu.al() );
                int lines = (int) (byte) cpu.al();
                int rul = (int) (byte) cpu.ch();
                int cul = (int) (byte) cpu.cl();
                int rlr = (int) (byte) cpu.dh();
                int clr = (int) (byte) cpu.dl();

                tracer.Trace( "scroll window up %u lines, rul %u, cul %u, rlr %u, clr %u\n",
                              lines, rul, cul, rlr, clr );

                if ( clr < cul || rlr < rul )
                    return;

                byte * pbuf = GetVideoMem();
                if ( 0 == lines || lines >= 25 )
                {
                    if ( 0 == lines )
                    {
                        tracer.Trace( "SCROLLUP CLEAR!!!!!!!!\n", lines );
                        for ( int row = rul; row <= rlr; row++ )
                            memcpy( pbuf + ( row * 80 * 2 + cul * 2 ), blankLine, 2 * ( 1 + clr - cul ) );
                    }
                    else
                        ClearDisplay();
                }
                else
                {
                    // likely data: lines = 1, rul = 1, cul = 0, rlr = 24, clr = 79
                    //          or: lines = 1, rul = 0, cul = 0, rlr = 24, clr = 79

                    for ( int row = rul; row <= rlr; row++ )
                    {
                        int targetrow = row - lines;
                        if ( targetrow >= rul )
                            memcpy( pbuf + ( targetrow * 80 * 2 + cul * 2 ),
                                    pbuf + ( row * 80 * 2 + cul * 2 ),
                                    2 * ( clr - cul ) );

                        if ( row >= ( rlr - lines ) )
                            memcpy( pbuf + ( row * 80 * 2 + cul * 2 ),
                            blankLine,
                            2 * ( 1 + clr - cul ) );
                    }
                }

                UpdateDisplay();
            }

            return;
        }
        case IntCmd( 0x10, 7 ):
        {
            // scroll window down: AL: # of lines to scroll. If 0, clear entire window
            // bh: display attribute for blank lines
            // ch: row number of upper left corner
            // cl: column number of upper left corner
            // dh: row number of lower left corner
            // dl: column number of lower right corner
            // lines are inserted at the top with all lines moving down.

            if ( g_use80x25 )
            {
                //printf( "%c[%dT", 27, cpu.al() );
                int lines = (int) (byte) cpu.al();
                int rul = (int) (byte) cpu.ch();
                int cul = (int) (byte) cpu.cl();
                int rlr = (int) (byte) cpu.dh();
                int clr = (int) (byte) cpu.dl();

                tracer.Trace( "scroll window down %u lines, rul %u, cul %u, rlr %u, clr %u\n",
                              lines, rul, cul, rlr, clr );

                if ( clr < cul || rlr < rul )
                    return;

                byte * pbuf = GetVideoMem();
                if ( 0 == lines || lines >= 25 )
                {
                    if ( 0 == lines )
                    {
                        tracer.Trace( "SCROLLDOWN CLEAR!!!!!!!!\n", lines );
                        for ( int row = rul; row <= rlr; row++ )
                            memcpy( pbuf + ( row * 80 * 2 + cul * 2 ), blankLine, 2 * ( 1 + clr - cul ) );
                    }
                    else
                        ClearDisplay();
                }
                else
                {
                    // likely data: lines = 1, rul = 1, cul = 0, rlr = 24, clr = 79
                    //          or: lines = 1, rul = 0, cul = 0, rlr = 24, clr = 79

                    for ( int row = rlr; row >= rul; row-- )
                    {
                        int targetrow = row + lines;
                        if ( targetrow <= rlr )
                            memcpy( pbuf + ( targetrow * 80 * 2 + cul * 2 ),
                                    pbuf + ( row * 80 * 2 + cul * 2 ),
                                    2 * ( clr - cul ) );

                        if ( row <= ( rul + lines ) )
                            memcpy( pbuf + ( row * 80 * 2 + cul * 2 ),
                                    blankLine,
                                    2 * ( 1 + clr - cul ) );
                    }
                }

                UpdateDisplay();
            }

            return;
        }
        case IntCmd( 0x10, 8 ):
        {
            // read attributes+character at current position. bh == display page
            // returns al character and ah attribute of character

            PerhapsFlipTo80x25();

            cpu.set_al( ' ' ); // hack for now
            cpu.set_ah( 0 );

            return;
        }
        case IntCmd( 0x10, 9 ):
        {
            // output character

            tracer.Trace( "  output character %#x, %#x times, attribute %#x, g_curRow %u, g_curCol %u\n",
                          cpu.al(), cpu.cx, cpu.bl(), g_curRow, g_curCol );

            char ch = cpu.al();

            if ( g_use80x25 )
            {
                byte * pbuf = GetVideoMem();
                DWORD offset = g_curRow * 2 * 80 + g_curCol * 2;

                for ( WORD t = 0; t < cpu.cx; t++ )
                {
                    pbuf[ offset ] = ch;
                    pbuf[ 1 + offset ] = cpu.bl();
                    g_curCol++;
                    if ( g_curCol > 80 )
                        g_curCol = 1;
                    SetCursorPos();
                }
            }
            else
            {
                if ( 0xd != ch )
                    printf( "%c", ch );
            }

            return;
        }
        case IntCmd( 0x10, 0xa ):
        {
            // output character only

            tracer.Trace( "  output character only %#x, %#x times, attribute %#x, g_curRow %u, g_curCol %u\n",
                          cpu.al(), cpu.cx, cpu.bl(), g_curRow, g_curCol );

            char ch = cpu.al();

            if ( g_use80x25 )
            {
                byte * pbuf = GetVideoMem();
                DWORD offset = g_curRow * 2 * 80 + g_curCol * 2;
                pbuf[ offset ] = ch;
                g_curCol++;
                SetCursorPos();
            }
            else
            {
                if ( 0xd != ch )
                    printf( "%c", ch );
            }

            return;
        }
        case IntCmd( 0x10, 0xf ):
        {
            // get video mode

            PerhapsFlipTo80x25();

            cpu.set_al( g_videoMode );
            cpu.set_ah( 80 ); // columns
            cpu.set_bh( 0 );  // active display page number

            return;
        }
        case IntCmd( 0x10, 0x10 ):
        {
            // set palette registers (ignore)

            return;
        }
        case IntCmd( 0x10, 0x11 ):
        {
            // character generator (ignore)

            return;
        }
        case IntCmd( 0x10, 0x12 ):
        {
            // alternate select. return some defaults

            if ( 0x10 == cpu.bl() )
            {
                cpu.bx = 0;
                cpu.cx = 0;
            }

            return;
        }
        case IntCmd( 0x10, 0x15 ):
        {
            // get physical display charactics

            cpu.ax = 0; // none

            return;
        }
        case IntCmd( 0x10, 0x1b ):
        {
            // unknown. qbasic generated .exe files call this?!?

            return;
        }
        case IntCmd( 0x10, 0xef ):
        {
            // unknown. qbasic generated .exe files call this?!?

            return;
        }
        case IntCmd( 0x12, 0 ):
        {
            // .com apps like Turbo Pascal instead read from the Program Segment Prefix

            cpu.ax = 0x280; // 640K conventional

            return;
        }
        case IntCmd( 0x16, 0 ):
        {
            // get character

            if ( g_use80x25 )
                UpdateDisplay();

            if ( int16ungetAvailable )
            {
                int16ungetAvailable = false;
                cpu.set_al( int16ungetChar );
                cpu.set_ah( int16ungetScancode );
            }
            else
            {
                cpu.set_ah( 0 );
                cpu.set_al( _getch() );
                if ( 0 == cpu.al() || 0xe0 == cpu.al() )
                    cpu.set_ah( _getch() ); // get the scan code
                else
                    cpu.set_ah( 0 );
            }

            tracer.Trace( "  returning character %#x '%c'\n", cpu.ax, printable( cpu.ax ) );

            return;
        }
        case IntCmd( 0x16, 1 ):
        {
            // check keyboard status. checks if a character is available. returns it if so but not removed from buffer

            if ( g_use80x25 )
                UpdateDisplay();

            cpu.set_ah( 0 );

            if ( _kbhit() )
            {
                cpu.fZero = false;
                cpu.set_al( _getch() );

                if ( 0 == cpu.al() || 0xe0 == cpu.al() )
                    cpu.set_ah( _getch() ); // get the scan code
                else
                    cpu.set_ah( 0 );

                int16ungetAvailable = true;
                int16ungetChar = cpu.al();
                int16ungetScancode = cpu.ah();

                tracer.Trace( "  returning character %#x '%c'\n", cpu.ax, cpu.ax );
            }
            else
                cpu.fZero = true;

            return;
        }
        default:
        {
            if ( 0x20 == interrupt_num )     // compatibility with CP/M apps for COM executables that jump to address 0 in its data segment
            {
                // terminate program
    
                g_haltExecution = true;
                cpu.end_emulation();
                return;
            }
            else if ( 0x22 == interrupt_num )
            {
                g_haltExecution = true;
                cpu.end_emulation();
                return;
            }
            else if ( 0x24 == interrupt_num )
            {
                printf( "Abort, Retry, Ignore?\n" );
                exit( 1 );
            }
            if ( 0x2a == interrupt_num )
            {
                // dos network / netbios
                cpu.set_ah( 0 ); // not network installed (for function ah==00 )
                return;
            }
            else if ( 0x2f == interrupt_num )
            {
                // dos multiplex interrupt; get installed state. AH has many possible values.
                cpu.set_al( 1 ); // not installed, do NOT install
                return;
            }
            else if ( 0x11 == interrupt_num )
            {
                // bios equipment determination
                cpu.ax = 0x002c;
                return;
            }

            tracer.Trace( "UNIMPLEMENTED pc interrupt!!!!: %02u == %#x, ah: %02u == %#x, al: %02u == %#x\n",
                          interrupt_num, interrupt_num, cpu.ah(), cpu.ah(), cpu.al(), cpu.al() );
            break;
        }
    }

    return;
} //i8086_invoke_interrupt

void InitializePSP( WORD segment, char * acAppArgs )
{
    * (WORD *)  ( GetMem( segment, 0x00 ) ) = 0x20cd;     // int 20 instruction to terminate app
    * (WORD *)  ( GetMem( segment, 0x02 ) ) = 0x9fff;     // top of memorysegment in paragraph form
    * (byte *)  ( GetMem( segment, 0x04 ) ) = 0x00;       // DOS uses 0

    * (WORD *)  ( GetMem( segment, 0x06 ) ) = 0xffff;     // .com programs bytes available in segment
    * (WORD *)  ( GetMem( segment, 0x08 ) ) = 0xdead;     // ?? DOS uses this value
    * (DWORD *) ( GetMem( segment, 0x0a ) ) = 0xf000;     // DWORD int 22 terminate address

    // 0x80: # of characters following command name at startup
    // 0x81: all characters after program name followed by a CR 0x0d

    byte len = strlen( acAppArgs );
    byte * pargs = GetMem( segment, 0x80 );
    * pargs = len;
    strcpy( (char *) pargs + 1, acAppArgs );
    pargs[ 1 + len ] = 0x0d; // CR ends the args
} //InitializePSP

static void usage( char const * perr )
{
    if ( perr )
        printf( "error: %s\n", perr );

    printf( "NT Virtual DOS Machine: emulates an MS-DOS 2.11 runtime environment enough to run some COM/EXE files on Win64\n" );
    printf( "usage: ntvdm [arguments] <DOS executable> [arg1] [arg2]\n" );
    printf( "  notes:\n" );
    printf( "            -c     don't auto-detect cursor positioning and set the console to 80x25\n" );
    printf( "            -i     trace instructions as they are executed (this is verbose!)\n" );
    printf( "            -p     show performance information\n" ); 
#ifdef I8086_TRACK_CYCLES
    printf( "            -s:X   speed in Hz. Default is 0, which is as fast as possible.\n" );
    printf( "                   for 4.77Mhz, use -s:4770000\n" );
#endif
    printf( "            -t     enable debug tracing to ntvdm.log\n" );
    printf( " [arg1] [arg2]     arguments after the .COM/.EXE file are passed to that command\n" );
    printf( "  examples:\n" );
    printf( "      ntvdm -c -t app.com foo bar\n" );
    printf( "      ntvdm turbo.com\n" );
    printf( "      ntvdm s:\\github\\MS-DOS\\v2.0\\bin\\masm small,,,small\n" );
    printf( "      ntvdm s:\\github\\MS-DOS\\v2.0\\bin\\link small,,,small\n" );
    exit( 1 );
} //usage

int main(int argc, char **argv)
{
    memset( memory, 0, sizeof memory );
    g_hConsole = GetStdHandle( STD_OUTPUT_HANDLE );

    for ( int x = 0; x < _countof( blankLine ); x++ )
        blankLine[ x ] = ' '; // 0 in the high byte attributes

    char * pcAPP = 0;
    BOOL trace = FALSE;
    ULONGLONG clockrate = 0;
    BOOL showPerformance = false;
    char acAppArgs[80] = {0};
    bool traceInstructions = false;

    for ( int i = 1; i < argc; i++ )
    {
        char *parg = argv[i];
        char c = *parg;

        if ( ( 0 == pcAPP ) && ( '-' == c || '/' == c ) )
        {
            char ca = tolower( parg[1] );

            if ( 's' == ca )
            {
                if ( ':' == parg[2] )
                    clockrate = (ULONGLONG) _strtoui64( parg+ 3 , 0, 10 );
                else
                    usage( "colon required after s argument" );
            }
            else if ( 't' == ca )
                trace = true;
            else if ( 'i' == ca )
                traceInstructions = true;
            else if ( 'p' == ca )
                showPerformance = true;
            else if ( 'c' == ca )
                g_forceConsole = true;
            else
                usage( "invalid argument specified" );
        }
        else
        {
            if ( 0 == pcAPP )
                pcAPP = parg;
            else if ( strlen( acAppArgs ) + 3 + strlen( parg ) < _countof( acAppArgs ) )
            {
                if ( 0 != acAppArgs[0] )
                    strcat( acAppArgs, " " );

                strcat( acAppArgs, parg );
            }
        }
    }

    tracer.Enable( trace, L"ntvdm.log", true );
    tracer.SetQuiet( true );
    cpu.trace_instructions( traceInstructions );

    if ( 0 == pcAPP )
        usage( "no command specified" );

    char acAPP[ MAX_PATH ];
    strcpy( acAPP, pcAPP );
    _strupr( acAPP );
    DWORD attr = GetFileAttributesA( acAPP );
    if ( INVALID_FILE_ATTRIBUTES == attr )
    {
        if ( strstr( acAPP, ".COM" ) || strstr( acAPP, ".EXE" ) )
        {
            usage( "can't find command file .com or .exe" );
        }
        else
        {
            strcat( acAPP, ".COM" );
            attr = GetFileAttributesA( acAPP );
            if ( INVALID_FILE_ATTRIBUTES == attr )
            {
                char * dot = strstr( acAPP, ".COM" );
                strcpy( dot, ".EXE" );
                attr = GetFileAttributesA( acAPP );
                if ( INVALID_FILE_ATTRIBUTES == attr )
                {
                    usage( "can't find command file" );
                }
            }
        }
    }

    bool isCOM = !strcmp( acAPP + strlen( acAPP ) - 4, ".COM" );

    cpu.cs = 0xF000;
    cpu.fTrap = false;

    // Set DL equal to the boot device: 0 for the FD.
    cpu.set_dl( 0 );

    // Set CX:AX equal to the hard disk image size, if present
    cpu.cx = 0;
    cpu.ax = 0;

    // global bios memory 
    byte * pbiosdata = GetMem( 0x40, 0 );
    * (WORD *) ( pbiosdata + 0x10 ) = 0x21;     // equipment list. diskette installed and initial video mode 0x20
    * (WORD *) ( pbiosdata + 0x13 ) = 640;      // contiguous 1k blocks (640 * 1024)
    * (byte *) ( pbiosdata + 0x49 ) = 2;        // video mode is 80,25, 16 grey
    * (WORD *) ( pbiosdata + 0x4a ) = 80;       // screen columns
    * (WORD *) ( pbiosdata + 0x4c ) = 0x1000;   // video regen buffer size
    * (WORD *) ( pbiosdata + 0x72 ) = 0x1234;   // soft reset flag (bypass memteest and crt init)
    * (byte *) ( pbiosdata + 0x84 ) = 25;       // screen rows

    // this is a byte where GWBASIC looks to check if it's being invoked recurisivly during a SHELL command
    * ( pbiosdata + 0x10f ) = 0;

    // 60:00 AKA 0x600 appears unused. Use it for the default interrupt routine. This is 8086 code.
    byte * pextradata = GetMem( 0x60, 0 );
    DWORD hookedVector = 0x00600000;               // this is in segment::offset format
    * (byte *) ( pextradata + 0x00 ) = i8086_opcode_interrupt; // this instruction will cause i8086_invoke_interrupt to be called
    * (byte *) ( pextradata + 0x01 ) = 0xca;       // far ret 2 instead of iret, which trashes the flags
    * (byte *) ( pextradata + 0x02 ) = 2;          // it's what the DOS bios does
    * (byte *) ( pextradata + 0x03 ) = 0;          // it's what the DOS bios does
    * (byte *) ( pextradata + 0x04 ) = 0xcf;       // int 1c return is an iret; don't bother calling back

    // claim bios and dos interrupt vectors (0-3f)
    DWORD * pVectors = (DWORD *) GetMem( 0, 0 );
    for ( DWORD intx = 0; intx < 0x40; intx++ )
        * (DWORD *) ( GetMem( 0, intx * 4 ) ) = hookedVector; // point all interrupts at the hook

    * (DWORD *) ( GetMem( 0, 0x1c * 4 ) ) = hookedVectorIRet; // tick tock 18x a second can just iret

    if ( isCOM )
    {
        // PSP: Program Segment Prefix for programs in DOS
        InitializePSP( AppSegment, acAppArgs );

        // load .com file
    
        FILE * fp = fopen( acAPP, "rb" );
        if (0 == fp )
            usage( "can't open input com file" );
    
        fseek( fp, 0, SEEK_END );
        long file_size = ftell( fp );
        fseek( fp, 0, SEEK_SET );
        int ok = fread( memory + AppSegmentOffset + 0x100, file_size, 1, fp ) == 1;
        if ( !ok )
            usage( "can't read .com file" );
        fclose( fp );
    
        // prepare to execute the COM file
      
        cpu.cs = AppSegment;
        cpu.ss = AppSegment;
        cpu.ds = AppSegment;
        cpu.es = AppSegment;
        cpu.sp = 0xffff;
        cpu.ip = 0x100;

        tracer.Trace( "loaded %s, app segment %04x, ip %04x\n", acAPP, cpu.cs, cpu.ip );
    }
    else
    {
        const DWORD DataSegmentOffset = 0x20000;
        const WORD DataSegment = DataSegmentOffset / 16;

        // PSP: Program Segment Prefix for programs in DOS
        InitializePSP( DataSegment, acAppArgs );

        // load the .exe file

        FILE * fp = fopen( acAPP, "rb" );
        if (0 == fp )
            usage( "can't open input exe file" );
    
        fseek( fp, 0, SEEK_END );
        long file_size = ftell( fp );
        fseek( fp, 0, SEEK_SET );
        vector<byte> theexe( file_size );
        int ok = fread( theexe.data(), file_size, 1, fp ) == 1;
        if ( !ok )
            usage( "can't read .exe file" );
        fclose( fp );

        ExeHeader & head = * (ExeHeader *) theexe.data();
        if ( 0x5a4d != head.signature )
            usage( "exe isn't MZ" );

        tracer.Trace( "loading app %s\n", acAPP );
        tracer.Trace( "looks like an MZ exe... size %u, size from blocks %u, bytes in last block %u\n",
                      file_size, ( (DWORD) head.blocks_in_file ) * 512, head.bytes_in_last_block );
        tracer.Trace( "relocation entry count %u, header paragraphs %u (%u bytes)\n",
                      head.num_relocs, head.header_paragraphs, head.header_paragraphs * 16 );
        tracer.Trace( "relative value of stack segment: %#x, initial sp: %#x, initial ip %#x, initial cs relative to segment: %#x\n",
                      head.ss, head.sp, head.ip, head.cs );
        tracer.Trace( "relocation table offset %u, overlay number %u\n",
                      head.reloc_table_offset, head.overlay_number );

        if ( head.reloc_table_offset >= 64 )
            usage( "probably not a 16-bit exe" );

        ULONG codeStart = 16 * (DWORD) head.header_paragraphs;
        ULONG cbUsed = head.blocks_in_file * 512;
        if ( 0 != head.bytes_in_last_block )
            cbUsed -= ( 512 - head.bytes_in_last_block );
        cbUsed -= codeStart; // don't include the header
        tracer.Trace( "bytes used by load module: %u, and code starts at %u\n", cbUsed, codeStart );

        const DWORD CodeSegmentOffset = DataSegmentOffset + 0x100;   //  data segment + 256 bytes for the psp
        const WORD CodeSegment = CodeSegmentOffset / 16;    

        byte * pcode = GetMem( CodeSegment, 0 );
        memcpy( pcode, theexe.data() + codeStart, cbUsed );
        tracer.Trace( "start of the code:\n" );
        DumpBinaryData( pcode, 0x200, 0 );

        // apply relocation entries

        ExeRelocation * pRelocationEntries = (ExeRelocation *) ( theexe.data() + head.reloc_table_offset );

        for ( WORD r = 0; r < head.num_relocs; r++ )
        {
            DWORD offset = pRelocationEntries[ r ].offset + pRelocationEntries[ r ].segment * 16;
            WORD * target = (WORD *) ( pcode + offset );
            //tracer.TraceQuiet( "relocation %u offset %u, update %#02x to %#02x\n", r, offset, *target, *target + CodeSegment );
            *target += CodeSegment;
        }

        cpu.cs = CodeSegment + head.cs;
        cpu.ss = CodeSegment + head.ss;
        cpu.ds = DataSegment;
        cpu.es = cpu.ds;
        cpu.sp = head.sp;
        cpu.ip = head.ip;
        cpu.ax = 0xffff; // no drives in use

        tracer.Trace( "CS: %#x, SS: %#x, DS: %#x, SP: %#x, IP: %#x\n",
                      cpu.cs, cpu.ss, cpu.ds, cpu.sp, cpu.ip );
    }

    g_DiskTransferAddress = (byte *) GetMem( cpu.ds, 0x80 ); // DOS default address
    g_haltExecution = false;

    CPerfTime perfApp;
    uint64_t total_cycles = 0; // this will be instructions if I8086_TRACK_CYCLES isn't defined
    CPUCycleDelay delay( clockrate );
    ULONGLONG ms_last = GetTickCount64();

    do
    {
        total_cycles += cpu.emulate( 1000 ); // 1000 cycles or instructions at a time

        if ( g_haltExecution )
            break;

        delay.Delay( total_cycles );

        if ( g_TimerInterrupt1CHooked ) // optimization since the default handler is just an iret
        {
            ULONGLONG ms_now = GetTickCount64();
            if ( ms_now != ms_last )
            {
                ms_last = ms_now;
                cpu.queue_interrupt( 0x1c );
            }
        }
    } while ( true );

    LONGLONG elapsed = 0;
    FILETIME creationFT, exitFT, kernelFT, userFT;
    if ( showPerformance )
    {
        perfApp.CumulateSince( elapsed );
        GetProcessTimes( GetCurrentProcess(), &creationFT, &exitFT, &kernelFT, &userFT );
    }

    g_consoleConfig.RestoreConsole();

    if ( showPerformance )
    {
        #ifdef I8086_TRACK_CYCLES
            printf( "8086 cycles:      %16ws\n", perfApp.RenderLL( (LONGLONG) total_cycles ) );
            printf( "clock rate: " );
            if ( 0 == clockrate )
            {
                printf( "      %16s\n", "unbounded" );
                uint64_t total_ms = total_cycles / 4770;
                printf( "approx ms at 4.77Mhz: %12ws  == ", perfApp.RenderLL( total_ms ) );
                uint16_t days = total_ms / 1000 / 60 / 60 / 24;
                uint16_t hours = ( total_ms % ( 1000 * 60 * 60 * 24 ) ) / 1000 / 60 / 60;
                uint16_t minutes = ( total_ms % ( 1000 * 60 * 60 ) ) / 1000 / 60;
                uint16_t seconds = ( total_ms % ( 1000 * 60 ) ) / 1000;
                uint16_t milliseconds = ( total_ms % 1000 );
                printf( "%u days, %u hours, %u minutes, %u seconds, %u milliseconds\n", days, hours, minutes, seconds, milliseconds );
            }
            else
                printf( "      %16ws Hz\n", perfApp.RenderLL( (LONGLONG ) clockrate ) );
        #endif

        ULARGE_INTEGER ullK, ullU;
        ullK.HighPart = kernelFT.dwHighDateTime;
        ullK.LowPart = kernelFT.dwLowDateTime;
    
        ullU.HighPart = userFT.dwHighDateTime;
        ullU.LowPart = userFT.dwLowDateTime;
    
        printf( "kernel CPU ms:    %16ws\n", perfApp.RenderDurationInMS( ullK.QuadPart ) );
        printf( "user CPU ms:      %16ws\n", perfApp.RenderDurationInMS( ullU.QuadPart ) );
        printf( "total CPU ms:     %16ws\n", perfApp.RenderDurationInMS( ullU.QuadPart + ullK.QuadPart ) );
        printf( "elapsed ms:       %16ws\n", perfApp.RenderDurationInMS( elapsed ) );
    }

    tracer.Shutdown();

    return 0;
} //main


